/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: simplyanalysis.proto
 *
 */

import Foundation
import SwiftProtobuf


public enum Apipb_DataInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case hourly // = 0
  case daily // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .hourly
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hourly
    case 1: self = .daily
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public init?(name: String) {
    switch name {
    case "hourly": self = .hourly
    case "daily": self = .daily
    default: return nil
    }
  }

  public init?(jsonName: String) {
    switch jsonName {
    case "HOURLY": self = .hourly
    case "DAILY": self = .daily
    default: return nil
    }
  }

  public init?(protoName: String) {
    switch protoName {
    case "HOURLY": self = .hourly
    case "DAILY": self = .daily
    default: return nil
    }
  }

  public var rawValue: Int {
    get {
      switch self {
      case .hourly: return 0
      case .daily: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }
  }

  public var json: String {
    get {
      switch self {
      case .hourly: return "\"HOURLY\""
      case .daily: return "\"DAILY\""
      case .UNRECOGNIZED(let i): return String(i)
      }
    }
  }

  public var hashValue: Int { return rawValue }

  public var debugDescription: String {
    get {
      switch self {
      case .hourly: return ".hourly"
      case .daily: return ".daily"
      case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
      }
    }
  }

}

public struct Apipb_GamePlayingRequest: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Apipb_GamePlayingRequest"}
  public var protoMessageName: String {return "GamePlayingRequest"}
  public var protoPackageName: String {return "apipb"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "games", swift: "games"),
    2: .same(proto: "from", swift: "from"),
    3: .same(proto: "to", swift: "to"),
    4: .same(proto: "interval", swift: "interval"),
  ]


  public var games: [String] = []

  ///  From is the unix seconds time
  public var from: Int64 = 0

  ///  To is the unix seconds time
  public var to: Int64 = 0

  public var interval: Apipb_DataInterval = Apipb_DataInterval.hourly

  public init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &games)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: &from)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: &to)
    case 4: try setter.decodeSingularField(fieldType: Apipb_DataInterval.self, value: &interval)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !games.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: games, fieldNumber: 1)
    }
    if from != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: from, fieldNumber: 2)
    }
    if to != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: to, fieldNumber: 3)
    }
    if interval != Apipb_DataInterval.hourly {
      try visitor.visitSingularField(fieldType: Apipb_DataInterval.self, value: interval, fieldNumber: 4)
    }
  }

  public func _protoc_generated_isEqualTo(other: Apipb_GamePlayingRequest) -> Bool {
    if games != other.games {return false}
    if from != other.from {return false}
    if to != other.to {return false}
    if interval != other.interval {return false}
    return true
  }
}

public struct Apipb_GamePlayingReply: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Apipb_GamePlayingReply"}
  public var protoMessageName: String {return "GamePlayingReply"}
  public var protoPackageName: String {return "apipb"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "data", swift: "data"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Apipb_GamePlayingReply
    var _data: Apipb_DataSet? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Apipb_DataSet.self, value: &_data)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _data != other._data {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._data = _data
      return clone
    }
  }

  private var _storage = _StorageClass()


  public var data: Apipb_DataSet {
    get {return _storage._data ?? Apipb_DataSet()}
    set {_uniqueStorage()._data = newValue}
  }
  public var hasData: Bool {
    return _storage._data != nil
  }
  public mutating func clearData() {
    return _storage._data = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Apipb_GamePlayingReply) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
